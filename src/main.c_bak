/*
 * Copyright (c) 2012-2014 Wind River Systems, Inc.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
#include <stdint.h>
#include <stdio.h>
#include <unistd.h>
#include <zephyr/net/mqtt.h>
#include <zephyr/net/socket.h>

/* Buffers for MQTT client. */
static uint8_t rx_buffer[256];
static uint8_t tx_buffer[256];

/* MQTT client context */
static struct mqtt_client client_ctx;
static struct mqtt_utf8 username = {.utf8 = (uint8_t *)"user",
                                    .size = sizeof("user") - 1};
static struct mqtt_utf8 password = {.utf8 = (uint8_t *)"pass",
                                    .size = sizeof("pass") - 1};
static struct mqtt_utf8 client_id = {.utf8 = (uint8_t *)"frdm_k64f_zephyr",
                                     .size = sizeof("frdm_k64f_zephyr") - 1};

/* MQTT Broker address information. */
static struct sockaddr_storage broker;

/* socket file descriptor */
static struct zvfs_pollfd fds[1];

/* connect flag */
static bool connected = false;

void mqtt_evt_handler(struct mqtt_client *client, const struct mqtt_evt *evt) {
  switch (evt->type) {
  case MQTT_EVT_CONNACK:
    if (evt->result != 0) {
      printf("MQTT connect failed %d\n", evt->result);
      connected = false;
      break;
    }
    printf("MQTT client connected!\n");
    connected = true;
    break;

  case MQTT_EVT_DISCONNECT:
    printf("MQTT client disconnected %d\n", evt->result);
    connected = false;
    break;

  default:
    break;
  }
}

int setup() {
  static int i = 0;
  printf("Connecting ... %d\n", i++);

  mqtt_client_init(&client_ctx);

  /* broker config */
  struct sockaddr_in *broker4 = (struct sockaddr_in *)&broker;
  broker4->sin_family = AF_INET;
  broker4->sin_port = htons(1883);
  inet_pton(AF_INET, "192.0.2.2", &broker4->sin_addr);

  /* client config */
  client_ctx.broker = &broker;
  client_ctx.evt_cb = mqtt_evt_handler;
  client_ctx.password = &password;
  client_ctx.user_name = &username;
  client_ctx.client_id = client_id;
  client_ctx.protocol_version = MQTT_VERSION_3_1_1;
  client_ctx.transport.type = MQTT_TRANSPORT_NON_SECURE;

  /* buffers */
  client_ctx.rx_buf = rx_buffer;
  client_ctx.rx_buf_size = sizeof(rx_buffer);
  client_ctx.tx_buf = tx_buffer;
  client_ctx.tx_buf_size = sizeof(tx_buffer);

  printf("Connecting ... %d\n", i++);
  /* connect */
  printf("Connecting id: %s, username: %s, password: %s\n",
         client_ctx.client_id.utf8, client_ctx.user_name->utf8,
         client_ctx.password->utf8);
  int rc = mqtt_connect(&client_ctx);
  if (rc != 0) {
    printf("Failed connecting mqtt_connect with error: %d\n", rc);
    perror("Failed connecting");
    return rc;
  }

  printf("Connecting ... %d\n", i++);
  /* mqtt is non-blocking, activate polling */
  fds[0].fd = client_ctx.transport.tcp.sock;
  fds[0].events = ZSOCK_POLLIN;
  poll(fds, 1, 5000);

  printf("Connecting ... %d\n", i++);
  mqtt_input(&client_ctx);
  if (!connected) {
    mqtt_abort(&client_ctx);
    printf("Connecting ... %d\n", i++);
    return -1;
  }

  return 0;
}

int main(void) {
  printf("Hello World from Zephyr in %s\n", CONFIG_BOARD_TARGET);

  /* connect to network */
  // printf("Waiting for network ...");
  // wait_for_network();

  if (setup() != 0) {
    while (1) {
    }
  }

  printf("Sleeping\n");
  sleep(30);

  printf("Disconnecting ...\n");
  mqtt_disconnect(&client_ctx);
  return 0;
}
